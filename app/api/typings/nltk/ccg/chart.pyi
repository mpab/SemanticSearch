"""
This type stub file was generated by pyright.
"""

from nltk.parse import ParserI
from nltk.parse.chart import AbstractChartRule, Chart, EdgeI
from nltk.ccg.logic import *
from nltk.sem.logic import *

"""
The lexicon is constructed by calling
``lexicon.fromstring(<lexicon string>)``.

In order to construct a parser, you also need a rule set.
The standard English rules are provided in chart as
``chart.DefaultRuleSet``.

The parser can then be constructed by calling, for example:
``parser = chart.CCGChartParser(<lexicon>, <ruleset>)``

Parsing is then performed by running
``parser.parse(<sentence>.split())``.

While this returns a list of trees, the default representation
of the produced trees is not very enlightening, particularly
given that it uses the same tree class as the CFG parsers.
It is probably better to call:
``chart.printCCGDerivation(<parse tree extracted from list>)``
which should print a nice representation of the derivation.

This entire process is shown far more clearly in the demonstration:
python chart.py
"""
class CCGEdge(EdgeI):
    def __init__(self, span, categ, rule) -> None:
        ...
    
    def lhs(self):
        ...
    
    def span(self):
        ...
    
    def start(self):
        ...
    
    def end(self):
        ...
    
    def length(self):
        ...
    
    def rhs(self):
        ...
    
    def dot(self):
        ...
    
    def is_complete(self):
        ...
    
    def is_incomplete(self):
        ...
    
    def nextsym(self):
        ...
    
    def categ(self):
        ...
    
    def rule(self):
        ...
    


class CCGLeafEdge(EdgeI):
    """
    Class representing leaf edges in a CCG derivation.
    """
    def __init__(self, pos, token, leaf) -> None:
        ...
    
    def lhs(self):
        ...
    
    def span(self):
        ...
    
    def start(self):
        ...
    
    def end(self):
        ...
    
    def length(self):
        ...
    
    def rhs(self):
        ...
    
    def dot(self):
        ...
    
    def is_complete(self):
        ...
    
    def is_incomplete(self):
        ...
    
    def nextsym(self):
        ...
    
    def token(self):
        ...
    
    def categ(self):
        ...
    
    def leaf(self):
        ...
    


class BinaryCombinatorRule(AbstractChartRule):
    """
    Class implementing application of a binary combinator to a chart.
    Takes the directed combinator to apply.
    """
    NUMEDGES = ...
    def __init__(self, combinator) -> None:
        ...
    
    def apply(self, chart, grammar, left_edge, right_edge):
        ...
    
    def __str__(self) -> str:
        ...
    


class ForwardTypeRaiseRule(AbstractChartRule):
    """
    Class for applying forward type raising
    """
    NUMEDGES = ...
    def __init__(self) -> None:
        ...
    
    def apply(self, chart, grammar, left_edge, right_edge):
        ...
    
    def __str__(self) -> str:
        ...
    


class BackwardTypeRaiseRule(AbstractChartRule):
    """
    Class for applying backward type raising.
    """
    NUMEDGES = ...
    def __init__(self) -> None:
        ...
    
    def apply(self, chart, grammar, left_edge, right_edge):
        ...
    
    def __str__(self) -> str:
        ...
    


ApplicationRuleSet = ...
CompositionRuleSet = ...
SubstitutionRuleSet = ...
TypeRaiseRuleSet = ...
DefaultRuleSet = ...
class CCGChartParser(ParserI):
    """
    Chart parser for CCGs.
    Based largely on the ChartParser class from NLTK.
    """
    def __init__(self, lexicon, rules, trace=...) -> None:
        ...
    
    def lexicon(self):
        ...
    
    def parse(self, tokens):
        ...
    


class CCGChart(Chart):
    def __init__(self, tokens) -> None:
        ...
    


def compute_semantics(children, edge):
    ...

def printCCGDerivation(tree):
    ...

def printCCGTree(lwidth, tree):
    ...

lex = ...
def demo():
    ...

if __name__ == "__main__":
    ...
